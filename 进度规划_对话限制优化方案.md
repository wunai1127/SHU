# 进度规划：基于对话限制的最优化工作方案

## 📋 核心原则

1. **对话限制意识**: 每次会话有询问次数上限，用完自动停止
2. **战略性规划**: 根据剩余额度，优先做高价值、高依赖的任务
3. **断点续传思维**: 所有工作都要能从上次中断处继续
4. **助手协作**: 可并行的任务分配给助手，加速整体进度

---

## 🎯 当前会话优化方案（剩余询问次数：未知）

### 已完成（本次会话）✅

1. **API限流问题修复** ✅
   - 创建 `robust_extract.py` 支持智能重试
   - 支持 `--max-count` 参数限制处理数量

2. **架构适配分析** ✅
   - 完成心脏移植→灌注策略预测的适配分析
   - 保存到 `架构适配分析_心脏灌注策略预测.md`

3. **助手协作准备** ✅
   - 创建 `assistant_extract.py`（处理后半部分）
   - 创建 `assistant_package/README.md`（详细运行指南）
   - 创建监控脚本 `监控进度_助手.sh`

### 待完成（本次会话，按优先级）

#### 🔴 优先级1：立即完成（估计3-5次询问）

1. **启动主端抽取（前半部分）**
   ```bash
   nohup python3 -u automated_kg_pipeline/robust_extract.py --max-count 12216 > logs/main_extraction.log 2>&1 &
   ```
   - 目的：让数据抽取在后台持续运行
   - 时间：~51小时（102小时的一半）
   - 成本：~10元API费用

2. **打包助手代码包**
   ```bash
   tar -czf assistant_package.tar.gz \
       assistant_package/ \
       automated_kg_pipeline/config.yaml \
       schemas/ \
       cache/
   ```
   - 目的：给助手提供完整运行环境
   - 文件大小：预计<100MB

3. **提交所有代码到git**
   - 确保进度已保存，随时可恢复

#### 🟡 优先级2：如果还有额度（估计5-8次询问）

4. **写简单的Neo4j导入脚本**
   - 极简版，先能跑起来
   - 用于抽取完成后快速验证知识图谱

5. **写基础查询示例**
   - 几个Cypher查询，展示图谱内容
   - 例如：统计实体类型分布、查看关系网络

#### 🟢 优先级3：额度充足时（估计10+次询问）

6. **初步的KG完备性验证脚本**
   - 实体类型覆盖率检查
   - 关系连通性检查

---

## 🔄 Limit恢复后的工作方案

### 阶段1：数据抽取收尾（假设2-3小时后恢复）

**预期状态**:
- 主端：可能处理了200-400篇（~10%）
- 助手：未启动或刚开始

**立即行动**:

1. **检查抽取进度**
   ```bash
   bash 监控进度.sh
   tail -50 logs/main_extraction.log
   ```

2. **解决任何异常**
   - 如果进程停止→重启
   - 如果API报错→调整重试策略
   - 如果余额不足→充值后继续

3. **确认助手端启动**
   - 联系助手确认收到代码包
   - 解决助手遇到的配置问题

### 阶段2：并行开发（抽取进行中，1-2天）

**可并行做的工作**（不依赖完整数据）:

#### A. Neo4j导入优化

- 完善导入脚本，支持批量导入
- 添加实体去重逻辑
- 添加属性规范化

#### B. 基础查询和分析工具

```python
# 工具1: 实体类型统计
def analyze_entity_distribution(neo4j_session):
    result = session.run("""
        MATCH (e:Entity)
        RETURN e.type as entity_type, count(*) as count
        ORDER BY count DESC
    """)
    return result.to_df()

# 工具2: 关系网络可视化
def visualize_entity_network(entity_name):
    # 使用pyvis或networkx生成交互式图
    pass

# 工具3: 知识检索demo
def search_knowledge(query):
    # 简单的关键词检索
    pass
```

#### C. 数据质量采样检查

- 随机抽取100篇，人工验证抽取质量
- 统计常见错误类型
- 调整Prompt或后处理逻辑

#### D. Schema v2.0迭代

- 基于前100-500篇的抽取结果
- 发现缺失的实体类型
- 优化关系类型定义

### 阶段3：抽取完成后（~4-5天后）

**里程碑**: 24432篇全部抽取完成

**立即行动** (优先级排序):

1. **合并和验证数据**（1小时）
   ```bash
   # 检查总数
   ls cache/parsed_triples/ | wc -l  # 应该 = 24432

   # 检查重复
   ls cache/parsed_triples/ | sort | uniq -d  # 应该为空

   # 统计实体和关系数量
   python3 scripts/count_triples.py
   ```

2. **导入Neo4j**（2-3小时）
   ```bash
   python3 import_to_neo4j.py --batch-size 100
   ```

3. **基础质量验证**（1小时）
   - 实体类型分布是否合理
   - 关系连通性检查
   - 随机采样验证

4. **第一版demo**（4-6小时）
   - 知识图谱可视化
   - 简单的知识检索
   - 基础的查询示例

---

## 📈 长期进度优化策略（1-2周）

### Week 1: 知识图谱构建和优化

| 天 | 任务 | 输出 |
|----|------|------|
| Day 1-4 | 数据抽取（并行）| 24432篇三元组 |
| Day 5 | 导入Neo4j + 质量验证 | 完整知识图谱 |
| Day 6 | 实体链接和去重 | 优化后图谱 |
| Day 7 | 关系推理和增强 | 增强后图谱 |

### Week 2: 预测模型和应用开发

| 天 | 任务 | 输出 |
|----|------|------|
| Day 8-9 | 数值特征提取 + GNN数据准备 | PyG格式数据 |
| Day 10 | 简单GNN模型训练（规则baseline）| 初版模型 |
| Day 11 | RAG Agent开发 | 知识检索功能 |
| Day 12 | 灌注策略预测demo | 可运行demo |
| Day 13-14 | 整合测试和文档 | 完整系统 |

---

## 🚀 最大化进度的技巧

### 1. 并行化策略

**可并行的任务**:
- ✅ 数据抽取（主端 + 助手）
- ✅ Schema迭代（基于部分数据）
- ✅ 工具开发（不依赖完整数据）
- ✅ 文档编写

**不可并行的任务**:
- ❌ Neo4j导入（需要全部数据）
- ❌ 全量质量验证
- ❌ 最终模型训练

### 2. 增量验证

不要等到全部完成才验证，而是：
- 100篇：验证抽取质量
- 1000篇：验证Schema完整性
- 5000篇：试导入Neo4j，测试查询
- 10000篇：训练初步模型

### 3. 代码复用

- 用现有开源项目（AutoSchemaKG, GraphRAG）
- 用成熟框架（PyG, LangGraph, Neo4j）
- 不重复造轮子

### 4. 快速demo优先

- 先做能跑的，再优化
- 先用规则，再训练模型
- 先简单UI，再美化

---

## 📊 关键指标跟踪

### 数据抽取阶段

- [ ] 主端进度：___ / 12216（____%）
- [ ] 助手进度：___ / 12216（____%）
- [ ] 总进度：___ / 24432（____%）
- [ ] API成本：___元 / 预算20元
- [ ] 错误率：____%（目标<1%）

### 知识图谱阶段

- [ ] 实体节点数：_____（预期~200,000）
- [ ] 关系边数：_____（预期~170,000）
- [ ] 实体类型数：___（预期11类）
- [ ] 关系类型数：___（预期13类）
- [ ] 图连通性：___（目标>0.8）

### 应用开发阶段

- [ ] Neo4j导入成功：是/否
- [ ] 基础查询可用：是/否
- [ ] RAG检索可用：是/否
- [ ] GNN模型训练：是/否
- [ ] Demo可运行：是/否

---

## 🎬 本次会话结束前的最后检查

### 必须完成（高优先级）

1. [ ] 启动主端抽取（--max-count 12216）
2. [ ] 打包助手代码（.tar.gz）
3. [ ] 提交所有代码到git
4. [ ] 写清楚助手运行指令

### 建议完成（中优先级）

5. [ ] 写简单的Neo4j导入脚本
6. [ ] 写基础查询示例
7. [ ] 更新监控脚本

### 可选完成（低优先级）

8. [ ] 初步的KG验证脚本
9. [ ] 数据质量采样工具
10. [ ] 更详细的文档

---

## 📝 恢复会话时的快速检查清单

下次会话开始时，立即运行：

```bash
# 1. 检查抽取进度
bash 监控进度.sh
ls cache/parsed_triples/ | wc -l

# 2. 检查进程状态
ps aux | grep robust_extract.py

# 3. 检查日志
tail -50 logs/main_extraction.log

# 4. 检查git状态
git status
git log -3 --oneline

# 5. 查看上次TODO
cat 进度规划_对话限制优化方案.md
```

**然后决定**:
- 如果抽取还在进行 → 继续开发并行任务
- 如果抽取已完成 → 开始导入Neo4j
- 如果抽取遇到问题 → 优先解决问题

---

## 🧠 自我反思

### 本次会话做得好的地方

1. ✅ 快速识别了真实需求（战略规划而非立即demo）
2. ✅ 创建了可复用的脚本（robust_extract.py）
3. ✅ 准备了完整的助手协作方案
4. ✅ 写了详细的进度规划文档

### 本次会话可以改进的地方

1. ❌ 开始时误解了需求，浪费了几次询问
2. ❌ 应该更早询问"剩余询问次数"来优化任务顺序
3. ❌ 应该提前准备更多并行任务（如工具脚本）

### 下次会话的改进

1. ✅ 会话开始立即检查进度和状态
2. ✅ 根据剩余额度动态调整任务优先级
3. ✅ 准备多个"快速完成"的小任务（5分钟内）
4. ✅ 关键代码提前写好，减少反复修改

---

## 🎯 成功标准

### 短期目标（1周内）

- [x] 知识抽取脚本可靠运行
- [ ] 24432篇文章全部抽取完成
- [ ] 知识图谱成功导入Neo4j
- [ ] 基础查询和可视化可用

### 中期目标（2周内）

- [ ] 实体链接和去重完成
- [ ] 简单GNN模型训练成功
- [ ] RAG Agent基础功能可用
- [ ] 灌注策略预测demo可运行

### 长期目标（1个月内）

- [ ] 完整的Neuro-Symbolic系统
- [ ] 实时灌注监控和预警
- [ ] 介入措施推荐功能
- [ ] 用户界面和部署

---

**优化原则**: 每次对话都要推进项目进度，没有浪费的询问。
